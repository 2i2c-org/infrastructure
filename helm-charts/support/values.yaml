prometheusIngressAuthSecret:
  enabled: false
  username: ""
  password: ""

redirects:
  rules: []

cluster-autoscaler:
  enabled: false
ingress-nginx:
  controller:
    podLabels:
      # nginx-ingress controllers need to communicate with the proxy pod (and only the proxy pod)
      # in clusters with networkpolicy enforcement enabled. Adding this label on the controller pod
      # allows that. https://z2jh.jupyter.org/en/stable/administrator/security.html#introduction-to-the-chart-s-four-network-policies
      # has more information.
      hub.jupyter.org/network-access-proxy-http: "true"
prometheus:
  networkPolicy:
    enabled: true
  alertmanager:
    # We do not use the Prometheus alertmanager component, as we already have Grafana
    # Grafana also has alerts, and the UI of grafana is much better than that of alertmanager
    # We also expose Grafana publicly behind auth anyway, so we can consolidate alerting with Grafana too
    enabled: false
  nodeExporter:
    tolerations:
      # Tolerate tainted jupyterhub user nodes
      - key: hub.jupyter.org_dedicated
        value: user
        effect: NoSchedule
      - key: hub.jupyter.org/dedicated
        value: user
        effect: NoSchedule
      # Tolerate tainted dask worker nodes
      - key: k8s.dask.org_dedicated
        value: worker
        effect: NoSchedule
      - key: k8s.dask.org/dedicated
        value: worker
        effect: NoSchedule
    updateStrategy:
      type: RollingUpdate
  pushgateway:
    enabled: false
  server:
    ingress:
      annotations:
        # Annotations required to enable basic authentication for any ingress
        # into prometheus server from the outside world. This secret is
        # created via templates/prometheus-ingress-auth/secret.yaml file in the support chart,
        # and the contents are controlled by config under prometheusIngressAuthSecret.
        # Ingress is not enabled by default, so whichever clusters we want
        # this we should enable it explicitly.
        nginx.ingress.kubernetes.io/auth-type: basic
        nginx.ingress.kubernetes.io/auth-secret: prometheus-ingress-auth-basic
        nginx.ingress.kubernetes.io/auth-realm: "Authentication Required"
        # If we enable external ingress into prometheus, we must secure it with HTTPS
        kubernetes.io/ingress.class: nginx
        cert-manager.io/cluster-issuer: letsencrypt-prod
    strategy:
      # We have a persistent disk attached, so the default (RollingUpdate)
      # can sometimes get 'stuck' and require pods to be manually deleted.
      type: Recreate
    resources:
      # Without this, prometheus can easily starve users
      requests:
        cpu: 0.2
        memory: 512Mi
      limits:
        cpu: 1
        memory: 2Gi
    labels:
      # For HTTP access to the hub, to scrape metrics
      hub.jupyter.org/network-access-hub: "true"
    persistentVolume:
      size: 100Gi
    # Keep data for at least 1 year
    retention: 366d
    service:
      type: ClusterIP
  kube-state-metrics:
    # kube-state-metrics stopped collecting *all* labels on all kubernetes objects as
    # prometheus labels, as it exploded the total number of metrics being collected. We
    # have to explicitly allow-list the labels we want. These are the ones needed for
    # the graphs from https://github.com/jupyterhub/grafana-dashboards to work
    metricLabelsAllowlist:
      - pods=[app,component,hub.jupyter.org/username,app.kubernetes.io/component]
      - nodes=[*]

grafana:
  persistence:
    # Attach a tiny 1G PVC with grafana for auth db as well as dashboard definition (not data) storage.
    # Matches what we do with JupyterHub
    enabled: true
  deploymentStrategy:
    type: Recreate
  service:
    # Grafana is exposed to the world via ingress
    type: ClusterIP

  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
      cert-manager.io/cluster-issuer: letsencrypt-prod

  datasources:
    datasources.yaml:
      apiVersion: 1
      datasources:
        # Automatically add the prometheus server in the same namespace as the grafana as a datasource
        - name: prometheus
          orgId: 1
          type: prometheus
          # This is the name of the kubernetes service exposed by the prometheus server
          url: http://support-prometheus-server
          access: proxy
          isDefault: true
          editable: false

# Enable a daemonset to install nvidia device plugin to GPU nodes
# AWS does not require this to be set, as eksctl sets this up automatically
nvidiaDevicePlugin:
  # For Azure-specific image, default to false
  azure:
    enabled: false
  # For GKE specific image, defaults to false
  gke:
    enabled: false
    version: "stable"

# Enables  https://github.com/yuvipanda/cryptnono/ to prevent cryptomining
cryptnono:
  enabled: true

# A placeholder as global values that can be referenced from the same location
# of any chart should be possible to provide, but aren't necessarily provided or
# used.
global: {}
