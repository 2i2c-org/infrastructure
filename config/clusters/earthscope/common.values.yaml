basehub:
  nfs:
    enabled: true
    pv:
      enabled: true
      # from https://docs.aws.amazon.com/efs/latest/ug/mounting-fs-nfs-mount-settings.html
      mountOptions:
        - rsize=1048576
        - wsize=1048576
        - timeo=600
        - soft # We pick soft over hard, so NFS lockups don't lead to hung processes
        - retrans=2
        - noresvport
      serverIP: fs-08e7747330d833d82.efs.us-east-2.amazonaws.com
      baseShareName: /
  jupyterhub:
    custom:
      2i2c:
        add_staff_user_ids_to_admin_users: true
        add_staff_user_ids_of_type: "google"
      jupyterhubConfigurator:
        enabled: false
      homepage:
        templateVars:
          org:
            url: https://www.earthscope.org/
            logo_url: https://github.com/2i2c-org/infrastructure/assets/7579677/589da909-86c2-4440-a42b-e3f1b59f49d5
          designed_by:
            name: "2i2c"
            url: https://2i2c.org
          operated_by:
            name: "2i2c"
            url: https://2i2c.org
          funded_by:
            name: "EarthScope Consortium"
            url: https://www.earthscope.org/
    hub:
      extraConfig:
        001-username-claim: |
          from oauthenticator.generic import GenericOAuthenticator
          from traitlets import List, Unicode

          class CustomGenericOAuthenticator(GenericOAuthenticator):
            # required_scopes functionality comes in from https://github.com/jupyterhub/oauthenticator/pull/719
            # Can be removed from here once that PR is merged
            required_scopes = List(
                Unicode(),
                config=True,
                help="""
                List of scopes that must be granted to allow login.

                All the scopes listed in this config must be present in the OAuth2 grant
                from the authorizing server to allow the user to login. We request all
                the scopes listed in the 'scope' config, but only a subset of these may
                be granted by the authorization server. This may happen if the user does not
                have permissions to access a requested scope, or has chosen to not give consent
                for a particular scope. If the scopes listed in this config are not granted,
                the user will not be allowed to log in.

                See the OAuth documentation of your OAuth provider for various options.
                """,
            )

            async def check_allowed(self, username, auth_model):
              if await super().check_allowed(username, auth_model):
                  return True

              if self.required_scopes:
                  granted_scopes = auth_model.get('auth_state', {}).get('scope', [])
                  missing_scopes = set(self.required_scopes) - set(granted_scopes)
                  if missing_scopes:
                      self.log.info(f"Denying access to user {username} - scopes {missing_scopes} were not granted, only {granted_scopes} were granted")
                      return False
                  else:
                      return True

              return False

            async def authenticate(self, *args, **kwargs):
              resp = await super().authenticate(*args, **kwargs)
              # Set scope to groups
              resp["groups"] = resp["auth_state"]["scope"]
              return resp

          def populate_token(spawner, auth_state):
            # For our deployment-service-check health check user, there is no auth_state.
            # So these env variables need not be set.
            if auth_state:
              token_env = {
                'AUTH0_ACCESS_TOKEN': auth_state.get("access_token", ""),
                'AUTH0_ID_TOKEN': auth_state.get("id_token", ""),
                'AUTH0_REFRESH_TOKEN': auth_state.get('refresh_token', '')
              }
              spawner.environment.update(token_env)

          c.Spawner.auth_state_hook = populate_token

          c.GenericOAuthenticator.manage_groups = True

          c.JupyterHub.authenticator_class = CustomGenericOAuthenticator

        05-gh-teams: |
          # Filters profileList based on group membership of JupyterHubs
          import copy

          from textwrap import dedent
          from tornado import web
          from oauthenticator.github import GitHubOAuthenticator

          original_profile_list = c.KubeSpawner.profile_list

          async def profile_list_allowed_groups_filter(spawner):
              """
              Returns the initially configured profile_list filtered based on the
              user's membership in each profile's `allowed_groups`. If
              `allowed_groups` isn't set for a profile, its not filtered out.

              `allowed_groups` is a list of JupyterHub groups.

              If the returned profile_list is filtered to not include a profile,
              an error is raised and the user isn't allowed to start a server.
              """
              if spawner.user.name == "deployment-service-check":
                  print("Ignoring allowed_teams check for deployment-service-check")
                  return original_profile_list

              groups = {g.name.casefold() for g in spawner.user.groups}
              print(f"User {spawner.user.name} is part of groups {groups}")

              # Filter out profiles with allowed_groups set if the user isn't part of any.
              allowed_profiles = []
              for profile in copy.deepcopy(original_profile_list):
                  allowed_groups = set(profile.get("allowed_groups"))
                  if allowed_groups is None:
                      # If no allowed_groups are set, allow access to everything
                      allowed_profiles.append(profile)
                      continue

                  if allowed_groups & groups:
                      print(f"Allowing profile {profile['display_name']} for user {spawner.user.name} based on group membership")
                      allowed_profiles.append(profile)
                      continue

              if len(allowed_profiles) == 0:
                  # If no profiles are allowed, user should not be able to spawn anything!
                  # If we don't explicitly stop this, user will be logged into the 'default' settings
                  # set in singleuser, without any profile overrides. Not desired behavior
                  # FIXME: User doesn't actually see this error message, just the generic 403.
                  error_msg = dedent(f"""
                  Your Group team membership is insufficient to launch any server profiles.

                  GitHub teams you are a member of that this JupyterHub knows about are {', '.join(groups)}.

                  If you are part of additional teams, log out of this JupyterHub and log back in to refresh that information.
                  """)
                  raise web.HTTPError(403, error_msg)

              return allowed_profiles

          # Only set this customized profile_list *if* we already have a profile_list set
          # otherwise, we'll show users a blank server options form and they won't be able to
          # start their server
          if c.KubeSpawner.profile_list:
              # Customize list of profiles dynamically, rather than override options form.
              # This is more secure, as users can't override the options available to them via the hub API
              c.KubeSpawner.profile_list = profile_list_allowed_groups_filter
      config:
        # JupyterHub:
        #   authenticator_class: auth0
        CustomGenericOAuthenticator:
          required_scopes:
            # This allows EarthScope to control who can login to the hub
            - geolab
        GenericOAuthenticator:
          scope:
            - openid
            # This gives us refresh token
            - offline_access
            # This allows EarthScope to control who can login to the hub
            # Everyone who logs in with Google and has a `@2i2c.org` email will be
            # automatically granted this scope, so we can test. See
            # https://2i2c.freshdesk.com/a/tickets/1280 for how this was granted.
            - geolab
            - geolab:dev
            - geolab:power
          extra_authorize_params:
            # This isn't an actual URL, just a string. Must not have a trailing slash
            audience: https://api.dev.earthscope.org
          username_claim: sub
          # Convert 'scope' from the OAuth2 response into JupyterHub groups
          manage_groups: true
          # claim_groups_key: 'scope'
        CILogonOAuthenticator:
          allowed_idps:
            http://github.com/login/oauth/authorize:
              default: true
              username_derivation:
                username_claim: "preferred_username"
            http://google.com/accounts/o8/id:
              username_derivation:
                username_claim: email
        Authenticator:
          enable_auth_state: true
          admin_users:
            # Chad Trebant, https://2i2c.freshdesk.com/a/tickets/1279
            - google-oauth2|117718799995701713253
    singleuser:
      profileList:
        - display_name: "Shared Small: 1-4 CPU, 8-32 GB"
          description: "A shared machine, the recommended option until you experience a limitation."
          allowed_groups:
            - geolab
            - geolab:dev
            - geolab:power
          profile_options: &profile_options
            image:
              display_name: Image
              unlisted_choice:
                enabled: True
                display_name: "Custom image"
                validation_regex: "^.+:.+$"
                validation_message: "Must be a publicly available docker image, of form <image-name>:<tag>"
                kubespawner_override:
                  image: "{value}"
              choices:
                jupyter-scipy:
                  display_name: Jupyter
                  slug: jupyter-scipy
                  kubespawner_override:
                    # FIXME: use quay.io/ for tags after 2023-10-20
                    image: jupyter/scipy-notebook:2023-06-27
                rocker-geospatial:
                  display_name: RStudio
                  slug: rocker-geospatial
                  kubespawner_override:
                    image: rocker/binder:4.3
                    image_pull_policy: Always
                    # Launch into RStudio after the user logs in
                    default_url: /rstudio
                    # Ensures container working dir is homedir
                    # https://github.com/2i2c-org/infrastructure/issues/2559
                    working_dir: /home/rstudio
          kubespawner_override:
            mem_guarantee: 7.234G
            cpu_guarantee: 0.1
            mem_limit: null
            node_selector:
              node.kubernetes.io/instance-type: r5.xlarge
        - display_name: "Small: 4 CPU, 32 GB"
          description: "A dedicated machine for you."
          allowed_groups:
            - geolab
            - geolab:dev
            - geolab:power
          profile_options: *profile_options
          kubespawner_override:
            mem_guarantee: 28.937G
            cpu_guarantee: 0.4
            mem_limit: null
            node_selector:
              node.kubernetes.io/instance-type: r5.xlarge
        - display_name: "Medium: 16 CPU, 128 GB"
          description: "A dedicated machine for you."
          profile_options: *profile_options
          allowed_groups:
            - geolab:dev
            - geolab:power
          kubespawner_override:
            mem_guarantee: 120.513G
            cpu_guarantee: 1.6
            mem_limit: null
            node_selector:
              node.kubernetes.io/instance-type: r5.4xlarge
        - display_name: "Large: 64 CPU, 512 GB"
          description: "A dedicated machine for you"
          profile_options: *profile_options
          allowed_groups:
            - geolab:power
          kubespawner_override:
            mem_guarantee: 489.13G
            cpu_guarantee: 6.4
            mem_limit: null
            node_selector:
              node.kubernetes.io/instance-type: r5.16xlarge

    scheduling:
      userScheduler:
        enabled: true
